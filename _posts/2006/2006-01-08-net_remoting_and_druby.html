---
layout: post
title: ".NET remotingとdRuby"
date: 2006-01-08 10:05:00.000000000 +09:00
type: post
published: true
status: publish
categories:
- ".NET Framework"
- Ruby
tags: []
meta: {}
author:
  login: skoji
  email: skoji@mac.com
  display_name: skoji
  first_name: ''
  last_name: ''
---
<p>最近.NET Frameworkをいじり始めました。<br />
.NETはVisualStudio .NETがなくても、無料の.NET Framework SDK(と適当なエディタ)だけで開発できるのな。不覚にも知らなかったです。とある事情で、まずは.NET remotingまわりを調査してます。<br />
MSDNだと<a href="http://www.microsoft.com/japan/msdn/library/default.asp?url=/japan/msdn/library/ja/cpguide/html/cpconnetremotingoverview.asp">このへん</a>から辿れば必要な情報にたどり着けるでしょう。</p>
<p><!--more--></p>
<h4> .NET remoting概要 </h4>
<p>.NET remotingは、アプリケーション境界・マシン境界を超えた先にあるオブジェクトを透過的に使う仕組みです。C#で.NET remotingは、ちょっと試す分にはとても簡単です。</p>
<h5>MarshalByRefObjectを継承したクラスを定義する</h5>
<p>これでこのオブジェクトは、アプリケーションドメインを超えて参照渡しできるようになります。<br />
(.NET CLRにはアプリケーションドメインとコンテキストって概念があるみたいだけどまだよく理解してない)</p>
<h5>サーバ側とクライアント側に、XMLっぽい構成ファイルを置く</h5>
<p>サーバ側は公開するオブジェクト名と公開するURL、クライアント側はアクセスするオブジェクトとそのURLを書きます。通信方法(tcpでバイナリデータ、httpでSOAP)やリモートオブジェクトの生成方法も指定できます(「アクティベーションの方法」という用語が使われてます)。</p>
<h5>サーバ側は構成ファイルを読み込んで、ただ起動してればよい</h5>
<p>構成ファイルを読み込むメソッドを呼び出して、ただwaitしていれば、リモートオブジェクトへの要求を受け付けるサーバのできあがり。</p>
<h5>クライアント側は構成ファイルを読み込んで、リモートオブジェクトをnewする</h5>
<p>newするだけでリモートオブジェクトが使えるようになるのだ。実際にリモートオブジェクトが生成されるのは、インスタンスメソッドが呼び出されたときのようです。<br />
とまあこんな感じで、とっかかりは簡単です。</p>
<h4> 参照渡しと値渡し</h4>
<p>さて、起動できるだけじゃだめで、リモートオブジェクトとクライアントの間ではなんらかの情報をやりとりしないといけません。それはメソッドの引数だったり戻り値だったりするわけです。<br />
これらの値もアプリケーションドメイン境界を超えるわけですから、次のいずれかをしないといけません。</p>
<ol>
<li>MarshalByRefObjectを継承する</li>
<li>serializableにしとく</li>
</ol>
<p>1.であれば参照渡しになります。2.を行えば値渡しになります。どちらもやらないと、実行時例外になります。両方やると参照渡しになります(MarshalByRefObject自体はserializableになってます)。<br />
とっかかりは簡単だったのに、この辺でもうめんどくさい感が漂ってきます。ぜんぜん透過的じゃないじゃん。リモートから使えるかどうか意識しなきゃだめじゃん。処理系がやってくれればいいじゃん。<br />
まあこのくらいは、最小限のおまじないと思って我慢しないといけないのかな。もし構文上は完全にローカルなオブジェクトと同じように扱えても、リモートオブジェクトかどうかは結局意識しないといけない場面があるでしょうし。</p>
<h4> インタフェース </h4>
<p>次にひっかかるのが、サーバとなるリモートオブジェクトの型です。<br />
これはクライアントとサーバのインタフェースですから、Interfaceで定義したくなっても不思議じゃありません。<br />
ところがInterfaceで定義しても、クライアント側では具象型を指定しないとリモートオブジェクトを取り出せないみたいです。そのあとInterfaceにキャストして使ってもいいわけですが、そもそも取り出すときは型知らないとダメだってのがちょっといやです。<br />
C#(とCLR)の仕様を考えれば仕方ないかな。<br />
リモートオブジェクトをInterfaceで定義して、クライアント側ではオブジェクトの取り出しの時以外はInterfaceとして扱う、という実装はもちろんできますが。</p>
<h4> dRubyだとどうなのさ </h4>
<p>型がダイナミックなrubyでのリモート処理にはdRubyってのがあります。ちょっと調べてみたのですが、上記2点の問題については次のことがわかりました</p>
<h5>値渡しと参照渡し</h5>
<p>rubyそのものと同じく参照渡しのみ。どうしても値渡ししたかったら、オブジェクトをdupする(てかこれは値渡しじゃなくて、コピーの参照渡しですな)。実際に通信路にはどんなデータが乗ってるのかは未調査でよくわかりません。</p>
<h5>インタフェース</h5>
<p>そもそもrubyにはインタフェースがないです。というか型が動的です。サーバとなるリモートオブジェクトを使うクライアントにとって重要なのはその型ではなくて、送ったメッセージに反応できるかどうかってことだけ。<br />
rubyなのでリモートの型とたとえば「リンク」しとく必要もなく、クライアント側をそのままでサーバ側オブジェクトをぜんぜん違う型にしちゃってもOK。同じメッセージに反応しさえすればいいのですな。</p>
